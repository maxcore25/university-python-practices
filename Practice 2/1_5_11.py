from itertools import groupby  # Для удобства вывода
from random import randint


def ex1():
    # Преобразовать элементы списка s из строковой в числовую форму
    s = ['1', '-1', '2', '-2', '0']
    for i in range(len(s)):
        s[i] = int(s[i])
    print('1)', s, type(s[0]))

    # Подсчитать количество различных элементов в последовательности s
    s = ['true', 'false', '123', '000', '999']
    print('2)', len(s))

    # Обратить последовательность s без использования функций
    s = [9, 8, 7, 6, 5, 4, 3, 23, 1, 0]
    s.reverse()
    print('3)', s)

    # Выдать список индексов, на которых найден элемент x в последовательности s
    s = ['x', 'y', 'x', 'z', 'kx']
    print('4)', [i for i in range(len(s)) if 'x' in s[i]])

    # Сложить элементы списка s с четными индексами
    s = [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
    print('5)', sum([s[i] for i in range(len(s)) if i % 2 == 0]))

    # Найти строку максимальной длины в списке строк s
    s = ['true', 'false', '123', '000', '999']
    print('6)', max(s, key=len), len(max(s, key=len)))


def ex5():
    words_list = [
        [
            'Коллеги,',
            'В то же время,',
            'Однако,',
            'Тем не менее,',
            'Следовательно,',
            'Соответственно',
            'Вместе с тем,',
            'С другой стороны,',
        ],
        [
            'парадигма цифровой экономики',
            'контекст цифровой трансформации',
            'диджитализация бизнес-процессов',
            'прагматичный подход к цифровым платформам',
            'совокупность сквозных технологий',
            'программа прорывных исследований',
            'ускорение блокчейн-транзакций',
            'экспоненциальный рост Big Data',
        ],
        [
            'открывает новые возможности для',
            'выдвигает новые требования',
            'несёт в себе риски',
            'расширяет горизонты',
            'заставляет искать варианты',
            'не оставляет шанса для',
            'повышает вероятность',
            'обостряет проблему',
        ],
        [
            'дальнейшего углубления',
            'бюджетного финансирования',
            'синергетического эффекта',
            'компрометации конфиденциальных',
            'универсальной коммодитизации',
            'несанкционированной кастомизации',
            'нормативного регулирования',
            'практического применения',
        ],
        [
            'знаний и компетенций.',
            'непроверенных гипотез.',
            'волатильных активов.',
            'опасных экспериментов.',
            'государственно-частных партнёрств.',
            'цифровых следов граждан.',
            'нежелательных последствий.',
            'внезапных открытий.',
        ],
    ]
    for i in range(5):
        print(words_list[i][randint(1, 7)], end=' ')


def ex11():
    # Вспомогательная функция для вывода результата на экран
    def rle_encode(info):
        return [(k, len(list(g))) for k, g in groupby(info)]

    def pr_preobr(string):
        # Добавляем разделитель, чтобы отслеживать перестановки
        string += '|'

        # Создание "таблицы", которая содержит все перестановки
        # Используем срезы :, чтобы помещать каждый символ в нужную ячейку
        permutations = [string[index:] + string[:index] for index, _ in enumerate(string)]
        # _ - это пропуск передачи значения. в данном случае счётчик будет начинать с 0

        # Сортировка по алфавиту
        permutations.sort()

        # Прохождение по последнему столбцу "таблицы"
        new_str = [y[-1] for y in permutations]

        # Запись последней буквы каждого столбца в новую строку
        new_str = ''.join(new_str)
        return new_str

    def obr_preobr(string):
        table = list('')
        # Создание списка, который содержит в себе прямое преобразование в качестве "столбца" для таблицы
        for i in range(len(string)):
            table.append(string[i])

        # Пока "столбец" не пройден до конца выполняется цикл
        for i in range(len(string) - 1):
            # Текущий "столбец" сортируем по алфавиту
            table.sort()

            # Добавляем идентичный входному "столбцу" "столбец"
            table = [string[i] + table[i] for i in range(len(string))]

        # Вернем ту строку, в исходной которой в конце стоял разделитель
        return table[[x[-1] for x in table].index('|')]

    # Входная строка
    st_r = 'CCCCATTTATTATCC'
    print('Строка:', st_r)
    result1 = pr_preobr(st_r)
    for_2 = result1

    # Возвращение копии строки, в которой все вхождения подстроки заменяются новой подстрокой (пустой)
    result1 = result1.replace('|', '')
    print('Результат прямого преобразования', result1)
    result2 = obr_preobr(for_2)

    # Возвращение копии строки, в которой все вхождения подстроки заменяются новой подстрокой (пустой)
    print('Результат обратного преобразования', result2.replace('|', ''))
    print('Обычное RLE-сжатие', rle_encode(st_r))
    print('RLE сжатие с пользованием преобразования Барроуза-Уилера', rle_encode(result1))


def main():
    print('-----Задание 1-----')
    ex1()
    print()
    print()

    print('-----Задание 5-----')
    ex5()
    print()
    print()
    print()

    print('-----Задание 11-----')
    ex11()


if __name__ == '__main__':
    main()
